<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brent A. Murray">
<meta name="author" content="Harry Seely">
<meta name="author" content="Yuwei Cao">
<meta name="author" content="Ahmed Ragab">

<title>Data Preparation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./images/TreeNetwork.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-acb86da7cc94e534617b9af23b514896.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    <img src="./images/TreeNetwork.png" alt="" class="navbar-logo light-content">
    <img src="./images/TreeNetwork.png" alt="" class="navbar-logo dark-content">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Deep Learning for Forest Inventories</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" aria-current="page"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./01_intro.html"> 
<span class="menu-text">1-Intro</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./02_data.html"> 
<span class="menu-text">2-Data</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./03_train.html"> 
<span class="menu-text">3-Train</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./04_validation.html"> 
<span class="menu-text">4-Validation</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./05_examples.html"> 
<span class="menu-text">5-Examples</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#deep-learning-for-enhanced-forest-inventories" id="toc-deep-learning-for-enhanced-forest-inventories" class="nav-link active" data-scroll-target="#deep-learning-for-enhanced-forest-inventories">Deep Learning for Enhanced Forest Inventories</a></li>
  <li><a href="#overview" id="toc-overview" class="nav-link" data-scroll-target="#overview">Overview</a>
  <ul class="collapse">
  <li><a href="#you-will-learn" id="toc-you-will-learn" class="nav-link" data-scroll-target="#you-will-learn">You will learn</a></li>
  </ul></li>
  <li><a href="#prerequisites" id="toc-prerequisites" class="nav-link" data-scroll-target="#prerequisites">Prerequisites</a></li>
  <li><a href="#instructors" id="toc-instructors" class="nav-link" data-scroll-target="#instructors">Instructors</a></li>
  <li><a href="#relevant-resources" id="toc-relevant-resources" class="nav-link" data-scroll-target="#relevant-resources">Relevant Resources</a></li>
  <li><a href="#data-download" id="toc-data-download" class="nav-link" data-scroll-target="#data-download">Data download</a></li>
  <li><a href="#summary-of-preprocessing-steps" id="toc-summary-of-preprocessing-steps" class="nav-link" data-scroll-target="#summary-of-preprocessing-steps">Summary of Preprocessing Steps</a></li>
  <li><a href="#extract-lidar-point-clouds-using-the-lidr-package" id="toc-extract-lidar-point-clouds-using-the-lidr-package" class="nav-link" data-scroll-target="#extract-lidar-point-clouds-using-the-lidr-package">Extract LiDAR point clouds using the lidR package</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/Brent-Murray/DeepLearningEFI/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Data Preparation</h1>
<p class="subtitle lead">Hands-on workshop</p>
</div>


<div class="quarto-title-meta-author column-page-left">
  <div class="quarto-title-meta-heading">Authors</div>
  <div class="quarto-title-meta-heading">Affiliations</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Brent A. Murray </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            University of British Columbia – Integrated Remote Sensing Studio
          </p>
      </div>
    <div class="quarto-title-meta-contents">
    <p class="author">Harry Seely </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            University of British Columbia – Integrated Remote Sensing Studio
          </p>
      </div>
    <div class="quarto-title-meta-contents">
    <p class="author">Yuwei Cao </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            University of British Columbia – Integrated Remote Sensing Studio
          </p>
      </div>
    <div class="quarto-title-meta-contents">
    <p class="author">Ahmed Ragab </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Natural Resources Canada - CanmetENERGY;<br>Polytechnique Montreal - Department of Mathematics and Industrial Engineering
          </p>
      </div>
  </div>

<div class="quarto-title-meta column-page-left">

      
  
    
  </div>
  


</header>


<section id="deep-learning-for-enhanced-forest-inventories" class="level1 hero">
<h1>Deep Learning for Enhanced Forest Inventories</h1>
<p>An introductory workshop for deep learning techniques for Enhanced Forest Inventories (EFIs) presented at the Canadian Cross-Country EFI Checkup.</p>
<p><a href="./setup.html" class="btn btn-primary">Get Started</a> <a href="./schedule.html" class="btn btn-outline-primary">View Schedule</a></p>
</section>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>This workshop covers a basic end-to-end deep learning workflow for EFI applications, covering an introduction into deep learning, to data prepartation, and finally a demo of model training, evaluation, and deployment. There will also be some examples of real world forest inventory deep learning applications showcasing some of the possibilities there are with these techniques.</p>
<section id="you-will-learn" class="level3">
<h3 class="anchored" data-anchor-id="you-will-learn">You will learn</h3>
<ul>
<li>What deep learning is and how it can be used for EFIs.</li>
<li>How to prepare and read in data for use in deep learning.</li>
<li>Basics of using the <a href="https://pytorch.org/" target="_blank">PyTorch</a> deep learning library.</li>
<li>Deep learning based forest attribute feature extraction.</li>
<li>Training a deep learning model for classification tasks.</li>
<li>Validation and testing of deep learning models.</li>
</ul>
</section>
</section>
<section id="prerequisites" class="level2">
<h2 class="anchored" data-anchor-id="prerequisites">Prerequisites</h2>
<ul>
<li>Comfortable with Python and Jupyter notebooks.</li>
<li>Google Colab will be used for running the live demo.</li>
</ul>
</section>
<section id="instructors" class="level2">
<h2 class="anchored" data-anchor-id="instructors">Instructors</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Affiliation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://www.researchgate.net/profile/Brent-Murray-4" target="_blank">Brent A. Murray</a></td>
<td>Integrated Remote Sensing Studio. University of British Columbia</td>
</tr>
<tr class="even">
<td><a href="https://www.researchgate.net/profile/Harry-Seely" target="_blank">Harry Seely</a></td>
<td>Integrated Remote Sensing Studio. University of British Columbia</td>
</tr>
<tr class="odd">
<td><a href="https://irsslab.forestry.ubc.ca/people/post-doctoral-fellows/" target="_blank">Yuwei Cao</a></td>
<td>Integrated Remote Sensing Studio. University of British Columbia</td>
</tr>
</tbody>
</table>


<p><img src="https://opendata.nfis.org/mapserver/PRF_Layout.jpg" class="img-fluid" style="width:60.0%" data-caption="" alt="Petawawa Forest Map"></p>
</section>
<section id="relevant-resources" class="level2">
<h2 class="anchored" data-anchor-id="relevant-resources">Relevant Resources</h2>
</section>
<section id="data-download" class="level2">
<h2 class="anchored" data-anchor-id="data-download">Data download</h2>
<p>PRF 2018 sample plots have a 14.1 m radius (625 m<sup>2</sup>)</p>
<p>The preprocessed data folder can be downloaded here</p>
<p><a href="https://ln5.sync.com/dl/88a6f5dd0#u24mrtkh-d5dqhart-zrg42shx-jfhhk8u5">https://ln5.sync.com/dl/88a6f5dd0#u24mrtkh-d5dqhart-zrg42shx-jfhhk8u5</a></p>
<p>The original height normalized LiDAR and sample plot data for the PRF can be downloaded below:</p>
<p>SPL LiDAR: <a href="https://opendata.nfis.org/downloads/petawawa/Raster/LiDAR_2018/PRF_benchmarking_harmonized_2018_ALS.zip">https://opendata.nfis.org/downloads/petawawa/Raster/LiDAR_2018/PRF_benchmarking_harmonized_2018_ALS.zip</a></p>
<p>Field Plots: <a href="https://opendata.nfis.org/downloads/petawawa/Vector/Forest%20Sample%20Plots/SPL2018_EFI_ground_plots.zip">https://opendata.nfis.org/downloads/petawawa/Vector/Forest%20Sample%20Plots/SPL2018_EFI_ground_plots.zip</a></p>
</section>
<section id="summary-of-preprocessing-steps" class="level2">
<h2 class="anchored" data-anchor-id="summary-of-preprocessing-steps">Summary of Preprocessing Steps</h2>
<ol type="1">
<li><p>Extract ALS point clouds corresponding to ground reference plots</p></li>
<li><p>Normalize X and Y coordinates</p></li>
<li><p>Compare 95th height percentile of measured tree heights with ALS derived 95th height percentile</p></li>
<li><p>Derive point cloud “labels”, establishing which plots are coniferous/deciduous/mixed</p></li>
<li><p>Split the data into training, validation, and test sets (i.e., splits)</p></li>
<li><p>Export point clouds to numpy files for later processing</p></li>
</ol>
</section>
<section id="extract-lidar-point-clouds-using-the-lidr-package" class="level2">
<h2 class="anchored" data-anchor-id="extract-lidar-point-clouds-using-the-lidr-package">Extract LiDAR point clouds using the lidR package</h2>
<p>Set filepaths and other global parameters</p>
<pre class="{r}"><code>
PROCESS_LIDAR = FALSE

PLOT_RADIUS = 14.1

PLOT_COORDS_FPATH = 'data/SPL2018_EFI_ground_plots/SPL2018_EFI_ground_plots/PRF_SPL2018_EFI_plots_pts_wgs84.shp'

PLOT_DATA_FPATH = 'data/SPL2018_EFI_ground_plots/SPL2018_EFI_ground_plots/PRF_CNL_SPL_CalibrationData_LiveDeadStems.xlsx'

TREE_SP_CODES_FPATH = 'data/mnrf_sp_codes.csv'

LIDAR_DIR = 'E:/PRF/3_tiled_norm'

PLOT_PC_DIR = "data/plot_point_clouds"

LABELS_FPATH = 'data/labels.csv'

ZQ95_FPATH = 'data/zq95.csv'
</code></pre>
<p>Load required R packages</p>
<pre class="{r}"><code>
library(lidR)
library(here)
library(sf)
library(dplyr)
library(mapview)
library(readxl)
library(ggplot2)
library(plotly)
library(reticulate)

# Import python numpy module using reticulate in quarto
np &lt;- reticulate::import("numpy")
</code></pre>
<p>Load the LiDAR and plot coordinates</p>
<pre class="{r}"><code>
#Read the normalized las catalog
ctg &lt;- readLAScatalog(LIDAR_DIR)

#Set some catalog processing parameters
opt_select(ctg) &lt;- "xyz"
opt_progress(ctg) &lt;- FALSE

#Read the plot coordinates and ensure CRS is correct
plot_centers &lt;- st_read(here(PLOT_COORDS_FPATH)) %&gt;%
    st_transform(lidR::crs(ctg)) %&gt;%
    st_zm() %&gt;%
    dplyr::rename(plot_id = Plot)

#Get vector representation of catalog area
ctg_sf &lt;- st_as_sf(lidR::as.spatial(ctg))

mapview(ctg_sf, layer.name = 'LiDAR Tiles') + mapview(plot_centers, 
                                                      col.regions = 'red', 
                                                      color = 'black',
                                                      layer.name = 'Ground Plots')
</code></pre>
<p>Define functions to process ALS data</p>
<pre class="{r}"><code>
extract_pc &lt;- function(coords, ctg){

      x = coords[1]
      y = coords[2]

      las &lt;- lidR::clip_circle(
        las = ctg,
        x = x,
        y = y,
        radius = PLOT_RADIUS)
      
      return(las)

    }

clean_pc &lt;- function(las) {
  
  las &lt;- lidR::filter_duplicates(las)
  
  las &lt;- lidR::classify_noise(las, sor(9,2))
  
  las &lt;- lidR::filter_poi(las, Classification != LASNOISE)
  
  return(las)
}

pc_to_matrix &lt;- function(las){

  pc &lt;- unname(st_coordinates(las))

  return(pc)

}

normalize_pc_xy &lt;- function(pc){

  pc[, 1] &lt;- pc[, 1] - mean(pc[, 1])
  pc[, 2] &lt;- pc[, 2] - mean(pc[, 2])

  return(pc)
}

calc_pc_zq95 &lt;- function(pc){

    zq95 &lt;- quantile(pc[, 3], probs = 0.95)

    return(zq95)

}

plot_pc &lt;- function(pc){

  pc_df &lt;- as.data.frame(pc)
  names(pc_df) &lt;- c('x', 'y', 'z')

  p &lt;- plot_ly(pc_df, x = ~x, y = ~y, z = ~z, type = "scatter3d", mode = "markers",
             marker = list(size = 3, color = ~z, colorscale = "Jet")) %&gt;%
            layout(title = "",
                  scene = list(
                    xaxis = list(title = "", showgrid = FALSE, showticklabels = TRUE, ticks = "outside"),
                    yaxis = list(title = "", showgrid = FALSE, showticklabels = TRUE, ticks = "outside"),
                    zaxis = list(title = "Z", showgrid = FALSE, showticklabels = TRUE, ticks = "outside")
                  ))

  return(p)

}

write_pc_to_npy &lt;- function(pc, plot_id, pc_out_dir){    
    
    pc_np &lt;- np$array(pc, dtype = "float32")

    np$save(file.path(here(pc_out_dir), paste0(plot_id, ".npy")), pc_np)

    return('')
    
    }
</code></pre>
<p>Extract plot point clouds from full aquisition</p>
<pre class="{r}"><code>
if(PROCESS_LIDAR){

  # Get a list of plot coordinates
  coords &lt;- split(st_coordinates(plot_centers), 
                    seq_len(nrow(plot_centers)))

  # Extract point clouds and store in list
  pc_ls &lt;- plyr::llply(coords, .fun = extract_pc, ctg = ctg, .progress='text')

  # Clean point clouds
  pc_ls &lt;- plyr::llply(pc_ls, .fun = clean_pc, .progress='text')

  # Convert point clouds to matrices
  pc_ls &lt;- plyr::llply(pc_ls, .fun = pc_to_matrix, .progress='text')

  # Normalize point clouds X &amp; Y coordinates (leave Z)
  pc_ls &lt;- plyr::llply(pc_ls, .fun = normalize_pc_xy, .progress='text')

  # Calculate zq95 for each point cloud to check alignment with plot data later
  als_derived_zq95_ls &lt;- plyr::llply(pc_ls, .fun = calc_pc_zq95, .progress='text')

  # Ensure the point cloud directory exists
  dir.create(PLOT_PC_DIR, recursive = TRUE, showWarnings = FALSE)

  # Export point clouds to numpy (.npy) files for use in python
  mapply(write_pc_to_npy, 
        pc = pc_ls,
        plot_id = plot_centers$plot_id,
        pc_out_dir=PLOT_PC_DIR)

  # Export ZQ95 values
  als_derived_zq95_df &lt;- data.frame(plot_id = plot_centers$plot_id,
                                    als_zq95 = as.numeric(als_derived_zq95_ls))

  write.csv(als_derived_zq95_df, ZQ95_FPATH, row.names=FALSE)

}

</code></pre>
<pre class="{r}"><code>
# Load an example pc
demo_pc &lt;- np$load(list.files(PLOT_PC_DIR, full.names = TRUE)[50])

# Visualize a point cloud
plot_pc(demo_pc)
</code></pre>
<p>Load tree measurements</p>
<pre class="{r}"><code>
# Load plot level tree measurements
trees_df &lt;- read_excel(PLOT_DATA_FPATH, sheet = 'Tree') %&gt;%
              dplyr::rename(plot_id = PlotName,
                            sp_code = tree_spec)


head(trees_df)</code></pre>
<p>Compare 95th height percentiles derived from LiDAR with the 95th percentile of measured tree heights</p>
<pre class="{r}"><code>
als_derived_zq95_df &lt;- read.csv(ZQ95_FPATH)

field_zq95_df &lt;- trees_df %&gt;%
                filter(!is.na(ht_meas)) %&gt;%
                group_by(plot_id) %&gt;%
                summarize(field_zq95 = quantile(ht_meas, probs = 0.95))

zq95_df &lt;- field_zq95_df %&gt;%
              left_join(als_derived_zq95_df, by = 'plot_id')

zq95_df %&gt;%
  ggplot(aes(x = field_zq95, y = als_zq95)) + 
  geom_point() + 
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +
  theme_minimal() + 
  coord_fixed(ratio = 1)
</code></pre>
<p>Add species information to trees data</p>
<pre class="{r}"><code>
# Load tree species codes
tree_sp_codes_df &lt;- read.csv(TREE_SP_CODES_FPATH) %&gt;%
                      mutate(species = trimws(species))


# Add species names to trees df
trees_df &lt;- trees_df %&gt;% left_join(tree_sp_codes_df, 
                                   by = 'sp_code') 


# View unique species
sort(round(table(trees_df['species']) / nrow(trees_df) * 100, 2), 
     decreasing = TRUE)
</code></pre>
<p>Classify each plot as either dominated by coniferous or deciduous species.</p>
<pre class="{r}"><code>
get_tvol_d_perc &lt;- function(trees){

  decid_tvol &lt;- trees %&gt;% 
                  filter(sp_type == 'd') %&gt;%
                  pull(tvol) %&gt;%
                  sum()

  plot_tvol &lt;- trees %&gt;% 
                  pull(tvol) %&gt;%
                  sum()

  perc_tvol_d &lt;- decid_tvol / plot_tvol * 100

  return(perc_tvol_d)

  }

perc_d_vec &lt;- vector(mode = 'numeric')

for(plot_id_i in unique(trees_df$plot_id)){

  plot_i_trees &lt;- trees_df[trees_df['plot_id'] == plot_id_i, ]

  perc_d_vec &lt;- append(perc_d_vec, get_tvol_d_perc(plot_i_trees))

}

# Assing plot to be either coniferous or deciduous dominant
perc_decid_df &lt;- data.frame(plot_id = unique(trees_df$plot_id),
                            perc_decid = perc_d_vec) %&gt;%
                  mutate(dom_sp_type = if_else(perc_decid &gt; 75, 'decid', 
                                       if_else(perc_decid &gt; 25 , 'mixed', 'conif')))


hist(perc_decid_df$perc_decid)

head(perc_decid_df)
</code></pre>
<p>Divide data into training, validation, and testing</p>
<pre class="{r}"><code>
# Establish the number of samples per split
n_test &lt;- round(nrow(perc_decid_df) * 0.20, 0)

n_train &lt;-  round(nrow(perc_decid_df) * 0.60, 0)

set.seed(14)
test_df &lt;- perc_decid_df %&gt;%
    slice_sample(n=n_test) %&gt;%
    mutate(split = "test")
  
set.seed(14)
train_df &lt;- perc_decid_df %&gt;%
    anti_join(test_df, by = "plot_id") %&gt;%
    slice_sample(n=n_train) %&gt;%
    mutate(split = "train")
  
val_df &lt;- perc_decid_df %&gt;%
    anti_join(train_df, by = "plot_id") %&gt;%
    anti_join(test_df, by = "plot_id") %&gt;%
    mutate(split = "val")


# Check splits
cat(
  sprintf("N Train Samples: %d (%.1f%%)\n", nrow(train_df), 100 * nrow(train_df) / nrow(perc_decid_df)),
  sprintf("N Val Samples:   %d (%.1f%%)\n", nrow(val_df), 100 * nrow(val_df) / nrow(perc_decid_df)),
  sprintf("N Test Samples:  %d (%.1f%%)\n", nrow(test_df), 100 * nrow(test_df) / nrow(perc_decid_df))
)

# Combine data frames
labels_df &lt;- dplyr::bind_rows(train_df, val_df, test_df)

# View frequency by split
ggplot(labels_df, aes(x = split, fill = dom_sp_type)) +
  geom_bar(position = "dodge") +
  geom_text(stat = "count", aes(label = ..count..), 
            position = position_dodge(width = 0.9), vjust = -0.5, color = "black", size = 5) +
  labs(x = "Data Split",
       y = "Number of Observations",
       fill = "Dominant Species Type") +
  theme_minimal() +
  scale_fill_brewer(
    palette = "Set2",
    labels = c("conif" = "Coniferous", "decid" = "Deciduous", "mixed" = "Mixed")
  )

head(labels_df)
</code></pre>
<p>Export labels</p>
<pre class="{r}"><code>
# Ensure that labels correspond to existing point cloud files
pc_flist &lt;- list.files(PLOT_PC_DIR, full.names = TRUE)
pc_id_ls &lt;- gsub(".npy", "", basename(pc_flist))

# Ensure labels contain the same plots as the ALS point clouds
labels_df &lt;- labels_df %&gt;% filter(plot_id %in% pc_id_ls)

# Export labels
write.csv(labels_df, LABELS_FPATH, row.names=FALSE)
</code></pre>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/Brent-Murray\.github\.io\/DeepLearningEFI\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/Brent-Murray/DeepLearningEFI/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>